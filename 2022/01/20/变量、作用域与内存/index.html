<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>变量、作用域与内存 | 海里睡人</title><meta name="keywords" content="前端开发,JavaScript"><meta name="author" content="海里睡人"><meta name="copyright" content="海里睡人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScript的变量是松散类型的，这就意味着变量的类型和值在脚本生命期内可以改变，因此会存在一些特别的问题。本文将探究JavaScript变量的存储和作用范围。 原始值和引用值ECMAScript的变量可分为两种类型——原始值与引用值。原始值包括Number、Boolean、String、Undefined、Null、Symbol六种类型，这六种类型的变量是按值访问的，也就是说这个变量实际代">
<meta property="og:type" content="article">
<meta property="og:title" content="变量、作用域与内存">
<meta property="og:url" content="https://jiebins.github.io/betternow.github.io/2022/01/20/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="海里睡人">
<meta property="og:description" content="JavaScript的变量是松散类型的，这就意味着变量的类型和值在脚本生命期内可以改变，因此会存在一些特别的问题。本文将探究JavaScript变量的存储和作用范围。 原始值和引用值ECMAScript的变量可分为两种类型——原始值与引用值。原始值包括Number、Boolean、String、Undefined、Null、Symbol六种类型，这六种类型的变量是按值访问的，也就是说这个变量实际代">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiebins.github.io/betternow.github.io/img/babara.png">
<meta property="article:published_time" content="2022-01-20T11:55:00.000Z">
<meta property="article:modified_time" content="2022-01-27T14:43:22.216Z">
<meta property="article:author" content="海里睡人">
<meta property="article:tag" content="前端开发">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiebins.github.io/betternow.github.io/img/babara.png"><link rel="shortcut icon" href="/betternow.github.io/img/favicon1.png"><link rel="canonical" href="https://jiebins.github.io/betternow.github.io/2022/01/20/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/betternow.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/betternow.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '变量、作用域与内存',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-27 22:43:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/betternow.github.io/css/mouse.css"><link rel="stylesheet" href="/betternow.github.io/css/footer.css"><link rel="stylesheet" href="/betternow.github.io/css/editor.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.64.0/codemirror.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.64.0/theme/idea.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bttn.css/0.2.4/bttn.min.css"><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/betternow.github.io/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/betternow.github.io/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/betternow.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/betternow.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/betternow.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/betternow.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/betternow.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/betternow.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/betternow.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/betternow.github.io/img/babara.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/betternow.github.io/">海里睡人</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/betternow.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/betternow.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/betternow.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/betternow.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/betternow.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/betternow.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">变量、作用域与内存</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-20T11:55:00.000Z" title="发表于 2022-01-20 19:55:00">2022-01-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-27T14:43:22.216Z" title="更新于 2022-01-27 22:43:22">2022-01-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="变量、作用域与内存"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>JavaScript的变量是松散类型的，这就意味着变量的类型和值在脚本生命期内可以改变，因此会存在一些特别的问题。本文将探究JavaScript变量的存储和作用范围。</p>
<h1 id="原始值和引用值"><a href="#原始值和引用值" class="headerlink" title="原始值和引用值"></a>原始值和引用值</h1><p>ECMAScript的变量可分为两种类型——原始值与引用值。原始值包括<code>Number</code>、<code>Boolean</code>、<code>String</code>、<code>Undefined</code>、<code>Null</code>、<code>Symbol</code>六种类型，这六种类型的变量是按值访问的，也就是说这个变量实际代表的就是这个值本身。而引用值就是对象<code>Object</code>，对象是按引用访问的，不能直接操作对象所在的内存空间，也就是说存储对象的变量实际上是一个指针，指向这个对象所在内存单元的地址，访问对象的时候按地址/引用访问。</p>
<h2 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h2><p>引用值可以随时添加、修改和删除属性和方法，但是原始值不能，给原始值添加属性也不会出错，比如</p>
<pre><code>let person = new Object();
person.name = &#39;Nicholas&#39;;
console.log(person.name); // Nicholas
let age = 17;
age.name = &#39;Nicholas&#39;;
console.log(age.name); // undefined
</code></pre><p>原始值初始化只能使用字面量创建，如果使用<code>new</code>创建，它就变成引用值了，比如</p>
<pre><code>let name1 = &#39;Nicholas&#39;;
let name2 = new String(&#39;Nicholas&#39;);
console.log(typeof name1); //string
console.log(typeof name2); // object
</code></pre><h2 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h2><p>原始值与引用值在复制时有很大的区别。通过变量将一个原始值赋给另一个变量时，会直接复制值给新的变量，两个变量是相互独立的，存储在内存不同的区域中，比如</p>
<pre><code>let a = 5;
let b = a;
console.log(b); // 5
let b = 10;
console.log(a); // 5，如果a和b不是独立的，那么修改b，a的值也会发生改变
</code></pre><p>（这里是复制原始值的图片）</p>
<p>把引用值从一个变量赋给另一个变量时，实际上是将一个指针赋给了新的变量，这时两个变量都指向内存相同的区域。两个变量不是相互独立的，修改变量所指的对象的属性，任意一个变量会发生改变，比如</p>
<pre><code>let a = new Object();
let b = a;
b.name = &#39;b&#39;;
console.log(a.name); // b
</code></pre><p>（这里是复制引用值的图片）</p>
<p>如果直接改变其中一个引用值变量的指向，它们指向的对象不同，两个变量又变成相互独立的了，比如</p>
<pre><code>let a = new Object();
let b = a;
b = new Object();
b.name = &#39;b&#39;;
console.log(a.name); // undefined
</code></pre><p>（这里是改变引用的图片）</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>ECMAScript所有函数的参数都是按值传递的，也就是说传递的只是实参的一个副本，而不是真正的实参。这种传参方式与上一节的复制值相同，原始值相互独立，引用值修改任意一个另一个会发生改变。因此，如果函数接收的对象参数，在函数体里面对对象进行修改会改变原来的变量，如果接收的是原始值则不会改变，比如</p>
<pre><code>function fun(a1, obj1) &#123;
  a1 = 5;
  obj1.name = &#39;obj&#39;;
&#125;
let a = 6;
let obj = new Object();
fun(a, obj);
console.log(a); // 6
console.log(obj.name); // obj
</code></pre><p>其他语言中的函数还存在一种传参方式——按引用传递。如果参数以按引用传递的方式传入函数内，即直接传入变量所在的地址，这样不管是原始值还是引用值在函数内部都可以直接访问地址修改实参的值。这就很容易与值传递中修改引用值时实参会变化这种情况混淆，让开发者认为JS的对象是引用传递的。实际上，在引用传递中，引用值变量在函数内修改它的指向实参变量的指向也会变化，而值传递不会，比如下面的例子</p>
<pre><code>function fun(obj) &#123;
  obj.name = &#39;obj&#39;;
  obj = new Object(); // 修改指针指向
  obj.name = &#39;newobj&#39;;
&#125;
let a = new Object();
fun(a);
console.log(a.name); // obj
</code></pre><h2 id="确定类型"><a href="#确定类型" class="headerlink" title="确定类型"></a>确定类型</h2><p>数据类型那篇笔记提到过可以使用<code>typeof</code>操作符来判断变量的数据类型，但只能判断它是属于哪种原始值，如果值是<code>null</code>或对象，返回的结果都是<code>object</code>，并且后面会提到JavaScript中常用的一些对象比如数组、日期等，它们使用<code>typeof</code>也会返回<code>object</code>，因为它们都是由<code>Object</code>类型派生出来的。为了更详细区分每一类对象，ECMAScript提供了<code>instanceof</code>操作符，语法如下</p>
<pre><code>res = variable instanceof constructor
</code></pre><p>如果给定变量是给定引用类型的实例，那么<code>instanceof</code>操作符会返回<code>true</code>，比如</p>
<pre><code>let arr = new Array();
console.log(arr instanceof Array); // true，arr是数组
console.log(arr instanceof Date); // false，arr不是日期
</code></pre><p>由于所有引用值都是<code>Object</code>的实例，所以使用<code>instanceof Object</code>都会返回<code>true</code>。</p>
<h1 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h1><p>执行上下文（context）是Javascript中很重要的一个概念，它保存着定义的变量、函数，是当前JavaScript代码被解析和执行时所在环境的抽象概念，运行的任何代码都是在执行上下文中运行的。</p>
<h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><p>执行上下文总共有三种类型：</p>
<ul>
<li><strong>全局执行上下文</strong>。全局执行上下文是最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。</li>
<li><strong>函数执行上下文</strong>。函数执行上下文是每次调用函数时该函数创建的执行上下文，每个函数都拥有自己的执行上下文，但只有在函数被调用时才会被创建。</li>
<li><strong><code>eval</code>函数上下文</strong>。<code>eval</code>函数上下文是指<code>eval</code>函数中的代码，但<code>eval</code>函数不常用，所以这里不再讨论。</li>
</ul>
<p>下面看一个例子</p>
<pre><code>var a = 1;
function fun () &#123;
  var b = 2;
  return b;
&#125;
function foo() &#123;
  return 4;
&#125;
let c = 3;
</code></pre><p>在例子中，除了函数的代码块外，其他的都是全局执行上下文，全局执行上下文中有变量<code>a</code>和<code>c</code>，函数<code>fun</code>和<code>foo</code>内的代码就在函数执行上下文中，变量<code>b</code>是<code>fun</code>上下文中的变量。</p>
<h2 id="执行上下文的存储方式"><a href="#执行上下文的存储方式" class="headerlink" title="执行上下文的存储方式"></a>执行上下文的存储方式</h2><p>执行上下文是以栈的方式存储起来的，称为执行上下文栈。在JavaScript代码开始执行时，首先进入全局环境，全局上下文被创建并入栈，此后调用函数时就进入相应的函数环境，相应函数上下文被创建并入栈，当处于栈顶的执行上下文代码执行完毕后，就会将其出栈。举个例子，比如下面代码</p>
<pre><code>function fun () &#123;
  foo();
&#125;
function foo () &#123;
  return 1;
&#125;
let a = 1;
fun();
foo();
</code></pre><p>上面的例子过程如下，首先创建全局上下文，然后压入执行上下文栈中。到<code>fun</code>函数调用时，<code>fun</code>函数上下文入栈；<code>fun</code>函数中还调用了<code>foo</code>函数，因此接着<code>foo</code>函数上下文也会入栈；<code>foo</code>函数执行完毕后，<code>foo</code>函数上下文出栈，<code>fun</code>函数继续执行，执行完毕后其函数上下文也跟着出栈；<code>foo</code>函数在执行一次，函数上下文入栈执行完毕后出栈，此时栈中只有全局上下文。</p>
<p>（这里是执行过程图片）</p>
<h2 id="执行上下文的结构"><a href="#执行上下文的结构" class="headerlink" title="执行上下文的结构"></a>执行上下文的结构</h2><h3 id="ES3中的执行上下文"><a href="#ES3中的执行上下文" class="headerlink" title="ES3中的执行上下文"></a>ES3中的执行上下文</h3><p>ES3中，每个执行上下文都有三个重要属性：变量对象、作用域链和<code>this</code>值。</p>
<h4 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h4><p>每个上下文都有一个关联的变量对象，这个上下文中定义的所有变量和函数都存在于这个对象上。一般变量对象会包含以下信息</p>
<ul>
<li>变量</li>
<li>函数声明</li>
<li>函数的形参</li>
</ul>
<p>看下面的例子</p>
<pre><code>function foo(arg) &#123;
  var a = arg * 7;
  return a;
&#125;
var fun = function () &#123;
  return 6;
&#125;
var b = 1;
</code></pre><p>例子中变量<code>a</code>、参数<code>arg</code>是函数<code>foo</code>的上下文的变量对象的属性，变量<code>b</code>、函数<code>foo</code>是全局上下文的变量对象的属性。函数<code>fun</code>不是全局上下文的变量对象的属性，因为函数表达式不包含在变量对象中。</p>
<p>函数上下文的变量对象是不能直接访问的，只有调用函数，创建函数上下文时才能访问，这时访问的对象叫活动对象。活动对象通过函数的<code>arguments</code>属性初始化。对于上面的例子中的<code>foo</code>函数，当调用它时，它就会创建函数上下文和其活动对象，活动对象的属性有函数的<code>arguments</code>对象和变量<code>b</code>。</p>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>JavaScript中函数也是一个对象，函数有一个属性<code>[[Scope]]</code>保存着函数父上下文的所有变量对象，函数创建时就存在这个属性。<code>[[Scope]]</code>呈链式结构，因此被叫做作用域链。当函数被调用时，函数的活动对象被激活，活动对象会被添加到作用域链的最前端。代码执行时的标志符解析是通过沿着作用域链逐级搜索标识符名称完成的，搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符，如果没找到，通常会报错。下面看一个例子</p>
<pre><code>var a = 1;
function fun() &#123;
  function foo () &#123;
    var b = 2;
    a = 3;
    c = 4
  &#125;
  var c = 5;
  foo();
  console.log(c);
&#125;
fun(); // 4
console.log(a); // 3
</code></pre><p>分析一下<code>fun</code>函数和<code>foo</code>函数的<code>[[Scope]]</code>属性。<code>fun</code>函数的<code>[[Scope]]</code>属性保存的是全局上下文的变量对象，也就是<code>window</code>对象，而<code>foo</code>函数的<code>[[Scope]]</code>属性保存的是<code>fun</code>函数的变量对象和全局上下文的变量对象。当调用函数<code>fun</code>时，<code>fun</code>函数内部也调用了<code>foo</code>函数，<code>foo</code>函数的活动对象添加到其<code>[[Scope]]</code>属性的最前端，然后查找变量<code>a</code>，发现<code>foo</code>的变量对象中并没有变量<code>a</code>，因此依次查找<code>fun</code>的变量对象和全局上下文的变量对象，在全局上下文的变量对象中找到了变量<code>a</code>，所以修改全局上下文的变量<code>a</code>的值为3。变量<code>c</code>的修改过程也类似。</p>
<p>（这里是作用域链的图）</p>
<h4 id="this值"><a href="#this值" class="headerlink" title="this值"></a><code>this</code>值</h4><p><code>this</code>值是执行上下文的一个重要属性，用来指明执行上下文是在哪个上下文中被触发的对象。<code>this</code>不是变量对象的属性，不会参加标识符解析过程，它的值是从执行上下文中直接获取的，并且在不同调用的场景下，<code>this</code>的值是不同的。</p>
<ul>
<li>在全局上下文中，<code>this</code>的值是全局对象，在浏览器中就是<code>window</code>对象。</li>
<li>当以正常方式调用函数时，<code>this</code>的值是全局对象，在浏览器中就是<code>window</code>对象。</li>
<li>当函数作为对象的方法调用时，<code>this</code>的值就是该对象。（如果将对象的方法赋给一个新的变量再调用，那么<code>this</code>为全局对象）</li>
<li>对于没有绑定到特定的对象上的函数，<code>this</code>值为全局对象</li>
<li>使用<code>call</code>、<code>apply</code>或<code>bind</code>，可以修改<code>this</code>值为任意对象</li>
<li>当一个函数被当作事件的句柄时，<code>this</code>的值为触发事件的元素</li>
</ul>
<p>（这里写一个<code>this</code>值的例子）</p>
<h4 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h4><p>ES3的执行上下文的生命周期分为三个阶段：创建阶段、执行阶段和销毁阶段。</p>
<h5 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h5><p>函数执行上下文的创建阶段发生在函数调用时并且在执行函数体内的具体代码之前，此时JS引擎会执行如下操作</p>
<ul>
<li>使用当前函数的<code>arguments</code>初始化一个变量对象与当前上下文关联，函数中声明的变量和函数作为属性添加到这个变量对象上。在这一阶段，会进行变量和函数的初始化声明，变量统一定义为<code>undefined</code>需要等到赋值时才会有确值，而函数会直接定义。（这就是变量提升，并且函数提升更靠前）</li>
<li>构建作用域链</li>
<li>确定<code>this</code>的值</li>
</ul>
<h5 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h5><p>在执行阶段中，JavaScript代码开始逐条执行，JS引擎开始执行对定义的变量赋值、顺着作用域链访问变量、如果有函数调用就创建一个新的执行上下文压入执行上下文栈中并移交控制权等操作。</p>
<h5 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h5><p>当函数执行完成后，当前执行上下文会弹出执行上下文栈并销毁，控制权交给上一层执行上下文。（闭包存在特殊情况，后面的文章会讨论这种情况）</p>
<h3 id="ES6中的执行上下文"><a href="#ES6中的执行上下文" class="headerlink" title="ES6中的执行上下文"></a>ES6中的执行上下文</h3><p>ES6对ES3的执行上下文部分概念做了调整，去除了变量对象和活动对象，以词法环境组件和变量环境组件替代，所以ES6中执行上下文分为三个部分：<code>this</code>值、词法环境和变量环境。</p>
<h4 id="词法环境-LexicalEnvironment"><a href="#词法环境-LexicalEnvironment" class="headerlink" title="词法环境(LexicalEnvironment)"></a>词法环境(LexicalEnvironment)</h4><p>根据ES6官方文档的定义，词法环境是基于ECMAScript代码的词法嵌套结构来定义标识符与特定变量和函数的关联关系。简而言之词法环境是一个包含标识符变量映射的结构，标识符表示变量或函数名，变量是对实际对象或原始值的引用。比如<code>let a = 6;``a</code>是标识符，6是变量。词法环境由环境记录和可能为<code>null</code>的外部词法环境组成：</p>
<ul>
<li>环境记录用于存储当前环境中的变量和函数声明的实际位置</li>
<li>外部环境引用对应着可以访问的其他外部环境。</li>
</ul>
<p>前文说到，执行上下文有全局执行上下文和函数执行上下文两种，对应的词法环境也有两种：</p>
<ul>
<li>全局环境。全局环境的环境记录是对象记录器，没有外部环境引用。全局环境拥有内建的<code>Object</code>、<code>Array</code>等、在环境记录内的原型函数和任何用户定义的全局变量，并且<code>this</code>值指向全局对象。</li>
<li>函数环境。函数环境的环境记录是声明式环境记录，存储着函数内部定义的变量，并且引用的外部环境可能是全局环境，或者任何包含此函数的外部函数环境。函数环境包含用户在函数定义的所有属性方法和一个<code>arguments</code>对象。</li>
</ul>
<p>两种词法环境可以用以下伪代码表示</p>
<pre><code>GlobalExectionContext = &#123;
  LexicalEnvironment: &#123;
    EnvironmentRecord: &#123;
      Type: &quot;Object&quot;,
      // 在这里绑定标识符
    &#125;,
    outer: &lt;null&gt;
  &#125;
&#125;

FunctionExectionContext = &#123;
  LexicalEnvironment: &#123;
    EnvironmentRecord: &#123;
      Type: &quot;Declarative&quot;,
      // 在这里绑定标识符
    &#125;
    outer: &lt;全局环境或者包含该函数的外部函数环境&gt;
  &#125;
&#125;
</code></pre><h4 id="变量环境-VariableEnvironment"><a href="#变量环境-VariableEnvironment" class="headerlink" title="变量环境(VariableEnvironment)"></a>变量环境(VariableEnvironment)</h4><p>变量环境也是一个词法环境，其环境记录包含了由变量声明在此执行上下文创建的绑定。变量环境和词法环境的区别在于变量环境只存储<code>var</code>的绑定，而词法环境存储函数声明和<code>let</code>与<code>const</code>绑定。比如下面的例子</p>
<pre><code>let a = 20;
const b = 30;
var c;
function multiply(e, f) &#123;
  var g = 20;
  return e * f * g;
&#125;
c = multiply(20, 30)
</code></pre><p>例子对应的执行上下文如下</p>
<pre><code>GlobalExectionContext = &#123;
  ThisBinding: &lt;Global Object&gt;,
  LexicalEnvironment: &#123;
    EnvironmentRecord: &#123;
      Type: &quot;Object&quot;,
      a: &lt;uninitialized&gt;,
      b: &lt;uninitialized&gt;,
      multiply: &lt;function&gt;
    &#125;,
    outer: &lt;null&gt;
  &#125;,
  VariableEnvironment: &#123;
    EnvironmentRecord: &#123;
      Type: &quot;Object&quot;,
      c: undefined
    &#125;,
    outer: &lt;null&gt;
  &#125;
&#125;

FunctionExectionContext = &#123;
  ThisBinding: &lt;Global Object&gt;,
  LexicalEnvironment: &#123;
    EnvironmentRecord: &#123;
      Type: &quot;Declarative&quot;,
      Arguments: &#123;0: 20, 1:30, length: 2&#125;
    &#125;,
    outer: &lt;GlobalLexicalEvironment&gt;
  &#125;,
  VariableEnvironment: &#123;
    EnvironmentRecord: &#123;
      Type: &quot;Declarative&quot;,
      g: undefined
    &#125;,
    outer: &lt;GlobalLexicalEnvironment&gt;
  &#125;
&#125;
</code></pre><p>只有遇到函数<code>multiply</code>调用时才会创建函数执行上下文。<code>let</code>和<code>const</code>定义的变量没有任何与之关联的值，但<code>var</code>定义的变量设置为<code>undefined</code>，这是因为在创建阶段，代码会被扫描并解析变量和函数声明，其中函数声明存储在环境中，而变量会被设置为<code>undefined</code>（使用<code>var</code>声明）或保持未初始化（在<code>let</code>和<code>const</code>的情况下）。这也是为什么可以在声明之前访问<code>var</code>定义的变量，但如果访问<code>let</code>和<code>const</code>定义的变量会报错的原因。</p>
<h4 id="执行阶段-1"><a href="#执行阶段-1" class="headerlink" title="执行阶段"></a>执行阶段</h4><p>ES6执行上下文的执行阶段与ES3的差不多，只是在执行阶段如果声明的实际位置找不到<code>let</code>变量的值会为分配<code>undefined</code>值。</p>
<h2 id="作用域链增强"><a href="#作用域链增强" class="headerlink" title="作用域链增强"></a>作用域链增强</h2><p>除了全局上下文和函数上下文，某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除，有下面两种情况</p>
<ul>
<li><code>try/catch</code>语句的<code>catch</code>块</li>
<li><code>with</code>语句</li>
</ul>
<p>使用<code>with</code>语句会向作用域链前端添加指定对象，；使用<code>catch</code>语句会创建一个新的变量对象，这个变量对象包含要抛出的错误对象的声明。</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>JavaScript可以通过自动内存管理实现内存分配和闲置资源回收，基本思路是：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一段时间就会自动执行。在运行过程中，垃圾回收程序必须跟踪记录哪个变量还会使用，哪个变量不会再使用，如何标记未使用变量有不同的实现方式，目前主要有两种标记策略：标记清理和引用计数。</p>
<h3 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h3><p>标记清理是JavaScript最常用的垃圾回收策略。当变量进入上下文时，这个变量会被加上存在于上下文中的标记，当变量离开上下文时，会被加上离开上下文的标记。垃圾回收程序运行时，会标记内存中存储的所有变量，然后它会将所有在上下文中的变量以及被在上下文中的变量引用的变量的标记去掉，随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数的思路是对每个值都记录它被引用的次数，声明变量并给它赋一个引用值时，这个值的引用数为1，如果这个值又赋给另一个变量，那么这个值的引用数加1。如果保存对该值的引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，说明没办法再访问这个值了，此时就可以安全收回其内存了。</p>
<p>引用计数存在一个严重的问题：循环引用，也就是对象A有一个指针指向对象B，对象B也引用了对象A，比如</p>
<pre><code>function problem () &#123;
  let objA = new Object();
  let objB = new Object();
  objA.someOtherObj = objB;
  objB.anotherObj = objA;
&#125;
</code></pre><p>在例子中，<code>objA</code>和<code>objB</code>通过各自的属性相互引用，这意味着第一个语句中<code>new Object()</code>这个语句生成的引用值的引用数为2，因为这个引用值被<code>objA</code>和<code>objB.anotherObj</code>引用，第二个语句同理。当函数调用结束时，<code>objA</code>和<code>objB</code>仍然存在，并且引用数永远不会变成0，如果多次调用该函数，则会导致大量内存永远不会被释放，这就是引用计数的弊端。为了避免出现循环引用，应该在确保不使用的情况下清除循环引用，比如</p>
<pre><code>objA.someOtherObj = null;
objB.anotherObj = null;
</code></pre><p>把变量设置为<code>null</code>实际会切断变量与其之前引用值之间的关系，当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>为了将内存占用保持在一个较小的值，从而使得页面性能更好，可以利用上面说的方法，将不用的值设置为<code>null</code>，从而释放其引用，这也叫解除引用。虽然解除一个值的引用不能直接导致相关内存被回收，但可以确保相关的值不在上下文中，下次垃圾回收就会被回收掉。</p>
<h3 id="使用let和const声明提升性能"><a href="#使用let和const声明提升性能" class="headerlink" title="使用let和const声明提升性能"></a>使用<code>let</code>和<code>const</code>声明提升性能</h3><p>由于<code>let</code>和<code>const</code>的作用域为块级作用域，使用这两个关键字可以更早地让垃圾回收程序介入，尽早回收内存，因为块级作用域包含在函数作用域里面，作用范围比较小。</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>内存泄漏有三种情况：</p>
<ul>
<li>不使用关键字定义变量，这时变量变成全局变量，这样函数或块执行结束后变量不会离开上下文，因为它定义在了全局上下文中，一直占用内存。</li>
<li>在定时器的回调函数引用了外部变量，则会在定时器执行完毕后才会释放的对应的变量。</li>
<li>使用闭包，返回的函数中引用了外部变量，只要返回的函数存在就不能释放掉该外部变量的内存，如果该变量很大就会出问题。</li>
</ul>
<h3 id="静态分配和对象池"><a href="#静态分配和对象池" class="headerlink" title="静态分配和对象池"></a>静态分配和对象池</h3><p>减少浏览器垃圾回收次数也是提升性能的一个方式。浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度，如果有很多对象被初始化，然后一下子又超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样就影响了性能，比如下面这个例子</p>
<pre><code>function addVector (a, b) &#123;
  let resultant = new Vector();
  resultant.x = a.x + b.x;
  resultant.y = a.y + b.y;
  return resultant;
&#125;
</code></pre><p>调用这个函数就会创建一个新对象，执行一系列运算最后返回调用者，如果这个对象声明周期很短，并且这个函数会频繁被调用，那么垃圾回收调度程序会发现这里对象更替速度很快，从而更频繁地安排垃圾回收。该问题的解决方案是不动态创建矢量对象，可以使用一个已有的矢量对象，比如</p>
<pre><code>function addVector (a, b, resultant) &#123;
  resultant.x = a.x + b.x;
  resultant.y = a.y + b.y;
  return resultant;
&#125;
</code></pre><p>但这需要在其他地方实例化这个<code>resultant</code>，为了创建实例不被垃圾回收程序盯上，可以使用对象池。对象池里是一组可回收的对象，应用程序可以向这个对象池请求一个对象，设置其属性、使用它，然后在操作完成后再把它还给对象池，这期间并没有发生对象初始化，所以垃圾回收探测就不会发现有对象更替。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">海里睡人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jiebins.github.io/betternow.github.io/2022/01/20/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/">https://jiebins.github.io/betternow.github.io/2022/01/20/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jiebins.github.io/betternow.github.io" target="_blank">海里睡人</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/betternow.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a><a class="post-meta__tags" href="/betternow.github.io/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="/betternow.github.io/img/babara.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/betternow.github.io/2022/01/08/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/"><img class="next-cover" src="/betternow.github.io/img/babara.png" onerror="onerror=null;src='/betternow.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript语言基础（三）——操作符、语句和函数</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/betternow.github.io/2021/12/03/JavaScript%E7%AE%80%E4%BB%8B/" title="JavaScript简介"><img class="cover" src="/betternow.github.io/img/babara.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-03</div><div class="title">JavaScript简介</div></div></a></div><div><a href="/betternow.github.io/2021/12/05/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/" title="JavaScript语言基础（一）——语法与变量声明"><img class="cover" src="/betternow.github.io/img/babara.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">JavaScript语言基础（一）——语法与变量声明</div></div></a></div><div><a href="/betternow.github.io/2021/12/03/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/" title="JavaScript语言基础（二）——数据类型"><img class="cover" src="/betternow.github.io/img/babara.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-03</div><div class="title">JavaScript语言基础（二）——数据类型</div></div></a></div><div><a href="/betternow.github.io/2022/01/02/%E4%B8%BA%E4%BB%80%E4%B9%880.1+0.2%E4%B8%8D%E7%AD%89%E4%BA%8E0.3/" title="为什么0.1+0.2不等于0.3？"><img class="cover" src="/betternow.github.io/img/babara.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-02</div><div class="title">为什么0.1+0.2不等于0.3？</div></div></a></div><div><a href="/betternow.github.io/2022/01/08/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/" title="JavaScript语言基础（三）——操作符、语句和函数"><img class="cover" src="/betternow.github.io/img/babara.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-08</div><div class="title">JavaScript语言基础（三）——操作符、语句和函数</div></div></a></div><div><a href="/betternow.github.io/2021/11/30/HTML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="HTML基础语法"><img class="cover" src="/betternow.github.io/img/babara.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-30</div><div class="title">HTML基础语法</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NDg1My8zMTMyMg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/betternow.github.io/img/avatar.jpg" onerror="this.onerror=null;this.src='/betternow.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">海里睡人</div><div class="author-info__description">你我注定能拥有彼此付出的温柔</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/betternow.github.io/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/betternow.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E5%80%BC"><span class="toc-number">1.</span> <span class="toc-text">原始值和引用值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">动态属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%80%BC"><span class="toc-number">1.2.</span> <span class="toc-text">复制值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.3.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">确定类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.</span> <span class="toc-text">执行上下文与作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">执行上下文的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">执行上下文的存储方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">执行上下文的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ES3%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.3.1.</span> <span class="toc-text">ES3中的执行上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">变量对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">作用域链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E5%80%BC"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">this值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">执行上下文的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.1.4.1.</span> <span class="toc-text">创建阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.1.4.2.</span> <span class="toc-text">执行阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.1.4.3.</span> <span class="toc-text">销毁阶段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.3.2.</span> <span class="toc-text">ES6中的执行上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83-LexicalEnvironment"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">词法环境(LexicalEnvironment)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%8E%AF%E5%A2%83-VariableEnvironment"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">变量环境(VariableEnvironment)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5-1"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">执行阶段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%A2%9E%E5%BC%BA"><span class="toc-number">2.4.</span> <span class="toc-text">作用域链增强</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E7%90%86"><span class="toc-number">3.0.1.</span> <span class="toc-text">标记清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">3.0.2.</span> <span class="toc-text">引用计数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8let%E5%92%8Cconst%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="toc-number">3.1.1.</span> <span class="toc-text">使用let和const声明提升性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-number">3.1.3.</span> <span class="toc-text">静态分配和对象池</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/betternow.github.io/2022/01/20/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/" title="变量、作用域与内存"><img src="/betternow.github.io/img/babara.png" onerror="this.onerror=null;this.src='/betternow.github.io/img/404.jpg'" alt="变量、作用域与内存"/></a><div class="content"><a class="title" href="/betternow.github.io/2022/01/20/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/" title="变量、作用域与内存">变量、作用域与内存</a><time datetime="2022-01-20T11:55:00.000Z" title="发表于 2022-01-20 19:55:00">2022-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/betternow.github.io/2022/01/08/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/" title="JavaScript语言基础（三）——操作符、语句和函数"><img src="/betternow.github.io/img/babara.png" onerror="this.onerror=null;this.src='/betternow.github.io/img/404.jpg'" alt="JavaScript语言基础（三）——操作符、语句和函数"/></a><div class="content"><a class="title" href="/betternow.github.io/2022/01/08/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/" title="JavaScript语言基础（三）——操作符、语句和函数">JavaScript语言基础（三）——操作符、语句和函数</a><time datetime="2022-01-08T02:04:00.000Z" title="发表于 2022-01-08 10:04:00">2022-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/betternow.github.io/2022/01/02/%E4%B8%BA%E4%BB%80%E4%B9%880.1+0.2%E4%B8%8D%E7%AD%89%E4%BA%8E0.3/" title="为什么0.1+0.2不等于0.3？"><img src="/betternow.github.io/img/babara.png" onerror="this.onerror=null;this.src='/betternow.github.io/img/404.jpg'" alt="为什么0.1+0.2不等于0.3？"/></a><div class="content"><a class="title" href="/betternow.github.io/2022/01/02/%E4%B8%BA%E4%BB%80%E4%B9%880.1+0.2%E4%B8%8D%E7%AD%89%E4%BA%8E0.3/" title="为什么0.1+0.2不等于0.3？">为什么0.1+0.2不等于0.3？</a><time datetime="2022-01-02T14:36:00.000Z" title="发表于 2022-01-02 22:36:00">2022-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/betternow.github.io/2021/12/05/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/" title="JavaScript语言基础（一）——语法与变量声明"><img src="/betternow.github.io/img/babara.png" onerror="this.onerror=null;this.src='/betternow.github.io/img/404.jpg'" alt="JavaScript语言基础（一）——语法与变量声明"/></a><div class="content"><a class="title" href="/betternow.github.io/2021/12/05/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/" title="JavaScript语言基础（一）——语法与变量声明">JavaScript语言基础（一）——语法与变量声明</a><time datetime="2021-12-05T14:10:00.000Z" title="发表于 2021-12-05 22:10:00">2021-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/betternow.github.io/2021/12/03/JavaScript%E7%AE%80%E4%BB%8B/" title="JavaScript简介"><img src="/betternow.github.io/img/babara.png" onerror="this.onerror=null;this.src='/betternow.github.io/img/404.jpg'" alt="JavaScript简介"/></a><div class="content"><a class="title" href="/betternow.github.io/2021/12/03/JavaScript%E7%AE%80%E4%BB%8B/" title="JavaScript简介">JavaScript简介</a><time datetime="2021-12-03T09:17:00.000Z" title="发表于 2021-12-03 17:17:00">2021-12-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 海里睡人</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/betternow.github.io/js/utils.js"></script><script src="/betternow.github.io/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><div class="aplayer no-destroy" data-id="122524667" data-server="netease" data-type="album" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.64.0/codemirror.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.64.0/mode/htmlmixed/htmlmixed.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.64.0/mode/css/css.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.64.0/mode/javascript/javascript.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.64.0/mode/xml/xml.min.js"></script><script src="/betternow.github.io/js/codeEditorGenerator.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>